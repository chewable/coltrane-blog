"""
Models for a weblog application.

"""

import datetime
from django.conf import settings
from django.db import models
from django.contrib.auth.models import User
from tagging.models import Tag
from template_utils.markup import formatter
from coltrane import managers, utils


class Category(models.Model):
    """
    A category that an Entry can belong to.
    
    """
    name = models.CharField(maxlength=250)
    slug = models.SlugField(prepopulate_from=('name',), unique=True,
                            help_text='Used in the URL for the category. Must be unique.')
    description = models.TextField(help_text='A short description of the category, to be used in list pages.')
    
    class Meta:
        verbose_name_plural = 'Categories'
        ordering = ['name']
    
    class Admin:
        pass
    
    def __str__(self):
        return self.name
    
    def get_absolute_url(self):
        return "/weblog/categories/%s/" % self.slug


class Entry(models.Model):
    """
    An entry in the weblog.
    
    Slightly denormalized, because it uses two fields each for the
    excerpt and the body: one for the actual text the user types in,
    and another to store the HTML version of the Entry (e.g., as
    generated by a text-to-HTML converter like Textile or Markdown).
    This saves having to run the conversion each time the Entry is
    displayed.
    
    Entries can be grouped by categories or by tags or both, or not
    grouped at all.
    
    """
    STATUS_CHOICES = (
        (1, 'Live'),
        (2, 'Draft'),
        (3, 'Hidden'),
        )
    
    # Metadata.
    author = models.ForeignKey(User)
    enable_comments = models.BooleanField(default=True)
    featured = models.BooleanField(default=False)
    pub_date = models.DateTimeField('Date posted', default=datetime.datetime.today)
    slug = models.SlugField(prepopulate_from=('title',),
                            help_text='Used in the URL of the entry. Must be unique for the publication date of the entry.')
    status = models.IntegerField(choices=STATUS_CHOICES, default=1,
                                 help_text='Only entries with "live" status will be displayed publicly.')
    title = models.CharField(maxlength=250)
    
    # The actual entry bits.
    body = models.TextField()
    body_html = models.TextField(editable=False)
    excerpt = models.TextField(blank=True, null=True)
    excerpt_html = models.TextField(blank=True, null=True, editable=False)
    
    # Categorization.
    categories = models.ManyToManyField(Category, filter_interface=models.HORIZONTAL, blank=True)
    tag_list = models.CharField('Tags', maxlength=250, blank=True, null=True,
                                help_text='Separate tag names with spaces; use hyphens for multi-word tags.')
    
    objects = models.Manager()
    live = managers.LiveEntryManager()
    
    class Meta:
        get_latest_by = 'pub_date'
        ordering = ['-pub_date']
        unique_together = (('slug', 'pub_date'),)
        verbose_name_plural = 'Entries'
    
    class Admin:
        date_hierarchy = 'pub_date'
        fields = (
            ('Metadata', { 'fields':
                           ('title', 'slug', 'pub_date', 'author', 'status', 'enable_comments') }),
            ('Entry', { 'fields':
                        ('excerpt', 'body') }),
            ('Categorization', { 'fields':
                                 ('tag_list', 'categories') }),
            )
        list_display = ('title', 'pub_date', 'enable_comments')
        list_filter = ('status',)
        search_fields = ('excerpt', 'body', 'title')
    
    def save(self):
        # Run markup filter before save.
        if self.excerpt:
            self.excerpt_html = formatter(self.excerpt)
        self.body_html = formatter(self.body)
        super(Entry, self).save()
        
        # Update tags after saving, because we want to make sure
        # the Entry has an id for setting up relations.
        self.tags = self.tag_list
        
    def __str__(self):
        return self.title
    
    def get_absolute_url(self):
        return "/weblog/%s/%s/" % (self.pub_date.strftime("%Y/%b/%d").lower(), self.slug)
    
    def comments_open(self):
        """
        Used to determine whether an entry is old enough that new
        comments on it should await approval before becoming public.
        
        """
        return self.enable_comments and datetime.datetime.today() - datetime.timedelta(settings.COMMENTS_MODERATE_AFTER) <= self.pub_date
    
    def _get_tags(self):
        """
        Returns the set of Tag objects for this Entry.
        
        Access this via the ``tags`` property.
        
        """
        return Tag.objects.get_for_object(self)
    
    def _set_tags(self, tag_list):
        """
        Sets the Tag objects for this Entry.
        
        Access this via the ``tags`` property.
        
        """
        Tag.objects.update_tags(self, tag_list)
    
    tags = property(_get_tags, _set_tags)


class Link(models.Model):
    """
    A link posted to the weblog.
    
    Denormalized in the same fashion as the Entry model, in order to
    allow text-to-HTML conversion to be performed on the
    ``description`` field.
    
    """
    # Metadata.
    enable_comments = models.BooleanField(default=True)
    post_elsewhere = models.BooleanField('Post to del.icio.us',
                                         default=settings.DEFAULT_EXTERNAL_LINK_POST,
                                         help_text='If checked, this link will be posted both to your weblog and to your del.icio.us account.')
    posted_by = models.ForeignKey(User)
    pub_date = models.DateTimeField(default=datetime.datetime.today)
    title = models.CharField(maxlength=250)
    slug = models.SlugField(prepopulate_from=('title',),
                            help_text='Must be unique for the publication date.')
    
    # The actual link bits.
    description = models.TextField(blank=True, null=True)
    description_html = models.TextField(editable=False, blank=True, null=True)
    via_name = models.CharField('Via', maxlength=250, blank=True, null=True,
                                help_text='The name of the person whose site you spotted the link on. Optional.')
    via_url = models.URLField('Via URL', verify_exists=False, blank=True, null=True,
                              help_text='The URL of the site where you spotted the link. Optional.')
    tag_list = models.CharField('Tags', maxlength=250, blank=True, null=True)
    url = models.URLField('URL', unique=True, verify_exists=False)
    
    class Meta:
        ordering = ['-pub_date']
        unique_together = (('slug', 'pub_date'),)
    
    class Admin:
        date_hierarchy = 'pub_date'
        fields = (
            ('Metadata', { 'fields':
                           ('title', 'slug', 'pub_date', 'posted_by', 'enable_comments', 'post_elsewhere') }),
            ('Link', { 'fields':
                      ('url', 'description', 'tag_list', 'via_name', 'via_url') }),
            )
        list_display = ('title', 'enable_comments')
        search_fields = ('title', 'description')
    
    def save(self):
        if not self.id and self.post_elsewhere:
            import pydelicious
            try:
                pydelicious.add(settings.DELICIOUS_USER, settings.DELICIOUS_PASSWORD, self.url, self.title, self.tag_list)
            except:
                pass # TODO: don't just silently quash a bad del.icio.us post
        if self.description:
            self.description_html = formatter(self.description)
        super(Link, self).save()
        self.tags = self.tag_list
    
    def __str__(self):
        return self.title
    
    def get_absolute_url(self):
        return "/weblog/links/%s/%s/" % (self.pub_date.strftime("%Y/%b/%d").lower(), self.slug)
    
    def comments_open(self):
        """
        Used to determine whether an entry is old enough that new
        comments on it should await approval before becoming public.
        
        """
        return self.enable_comments and datetime.datetime.today() - datetime.timedelta(settings.COMMENTS_MODERATE_AFTER) <= self.pub_date
    
    def _get_tags(self):
        """
        Returns the set of Tag objects for this Link.
        
        Access this via the ``tags`` property.
        
        """
        return Tag.objects.get_for_object(self)
    
    def _set_tags(self, tag_list):
        """
        Sets the Tag objects for this Link.
        
        Access this via the ``tags`` property.
        
        """
        Tag.objects.update_tags(self, tag_list)
    
    tags = property(_get_tags, _set_tags)
